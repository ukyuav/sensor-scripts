#+title: UAVLAB Serial PTH (Samamet) Script Documentation
#+author: Justin Tussey
#+date: 2024-05-22
#+options: toc:2

#+begin_comment
pandoc UAVLAB-serial-pth-documentation.org -o UAVLAB-serial-pth-documentation.pdf --template eisvogel --listings

Using modified eisvogel latex template to have underlined linked
https://github.com/jlacko/pandoc-latex-template <- the one I'm using
https://github.com/Wandmalfarbe/pandoc-latex-template <- main link
#+end_comment

* Table of Contents :toc:
- [[#code-overview][Code Overview]]
  - [[#global-variables][Global Variables]]
  - [[#serial-initialization][Serial Initialization]]
  - [[#update-function][Update Function]]
  - [[#verifying-checksum][Verifying Checksum]]
  - [[#parsing-data][Parsing Data]]
  - [[#logging][Logging]]
  - [[#important-notes][Important Notes]]
- [[#important-links][Important Links]]

* Code Overview
Over view of the ~serial_pth.lua~ script for decoding and logging data from the
PTH serial sensor

#+begin_quote
*NOTE*: This document is in the order that the code is ran, not in the order
that it is organized in the file.
#+end_quote

** Global Variables
#+begin_src lua
-- variable to count iterations without getting message
local loops_since_data_received = 0

-- table to hold the message that is currently being assembled
local message_table = {}

-- error type table
local ERROR_LIST = {
  "No data received",      -- 1
  "Checksum fail",         -- 2
  "Data parsing fail",     -- 3
}
#+end_src

The ~loops_since_data_received~ variable stores how many loops since a new byte
of data has been received on the serial line. If this value goes above a certain
count, we can assume that the sensor is most likely disconnected, and can report
and log an error

The ~message_table~ table stores the bytes of the message that we are currently
assembling.

The ~ERROR_LIST~ table holds a list of possible errors we can receive. We use
this list to pass through the kind of error we are experiencing to the
~log_error()~ function to be logged in the BIN file for later reference.

** Serial Initialization
#+begin_src lua
-- initialize serial connection
local BAUD_RATE = 9600

-- find the serial first (0) scripting serial port instance
-- SERIALx_PROTOCOL 28
local PORT = assert(serial:find_serial(0),"Could not find Scripting Serial Port")

-- begin the serial port
PORT:begin(BAUD_RATE)
PORT:set_flow_control(0)
#+end_src

This sets up the serial connection between the PTH and the flight controller.
A baudrate of 9600 is used since this is the speed the sensor operates at.

After we set the baudrate, we then find the first serial port that is currently
open and using protocol 28, which is the ArduPilot protocol for scripting.

#+begin_quote
*NOTE*:
1. make sure to set the correct baudrate of 9600 and protocol 28 on the serial
   line being used to ensure the sensor is connected.
2. If you have multiple serial ports set to protocol 28 (Scripting), make sure
   to have the Samamet on the highest port, or to set the =0= in ~find_serial()~
   to a =1= to find the second port.
#+end_quote

If we cannot find a serial port with the scripting protocol, the script throws
an error.

The serial initialization is pulled from the ArduPilot [[https://github.com/ArduPilot/ardupilot/blob/master/libraries/AP_Scripting/examples/Serial_Dump.lua][Serial Dump example]].

** Update Function
Once the serial initialization is completed, the script then jumps to the end
of the file (since that there is no other code outside of the functions) and
runs the following return statement.

#+begin_src lua
return update() -- run immediately before starting to reschedule
#+end_src

This statement calls the ~update()~ function, which is the main function in most
ArduPilot lua scripts.

#+begin_src lua
  local n_bytes = PORT:available()

  -- If we have received no bytes or have not received any new bytes, increment
  -- the count of loops without data. If it reaches 11 or more
  -- (100ms * 11 = 1.1sec), then log an error.
  if n_bytes <= 0 then
    loops_since_data_received = loops_since_data_received + 1
    if loops_since_data_received >= 11 then
      log_error(ERROR_LIST[1])
      -- Send error message to mission planner with priority 0 (error)
      gcs:send_text(0, "ERROR: PTH has failed to send data")
      -- clear incomplete message (if there is one)
      message_table = {}
    end
    return update, 100
  end
#+end_src

First we update ~n_bytes~ and we check if it is zero. If it is zero, this means
that there is no new data on the bus, meaning the sensor is disconnected, or it
has not sent its data yet.

Since we run the loop ten times per second we keep track of how many loops have
gone by with the ~loops_since_data_received~ counter. If we reach eleven or more
iterations without new data, we log an error with the ~log_error()~ function
(This will be discussed further in the [[#logging]["Logging"]] section), send an error out to
the Mission Planner output, and clear the current message that has been parsed
in the event that the sensor was disconnected in the middle of a data
transmission.

We derive this number of failed loops from how often we schedule the ~update()~
function to run, which is every 100 milliseconds, and how often the PTH sends
out its data, which is every second. To ensure that we are not flagging the time
in between data transmissions from the sensor as an error, we need to wait more
than one second. By waiting for eleven failed loops, we guarantee that we are
waiting at least 1.1 seconds before we log an error ($100\text{ms} \cdot 11 =
1100 = 1.1\text{sec}$). This gives the PTH time to send its data and will
prevent us from logging any false errors.


#+begin_src lua
  -- read bytes from the serial line until we hit '0x0A' which is <LF>, the
  -- ending of the message. Then process the message
  loops_since_data_received = 0
  while n_bytes > 0 do
    local byte = PORT:read()
    if byte == 0x0A then
      -- ommited for later section
    end
    table.insert(message_table, byte)
    n_bytes = n_bytes - 1
  end

  return update, 100 -- schedule the update function to
#+end_src

If there are any bytes available, we read one off of the serial line. We first
check if it is the ASCII character =0x0A=, which is the 'line feed' or =<LF>=
character, which is that character that the Samamet uses to signify the end of a
message. If the current bytes is not the line feed character, we simply add the
byte to ~message_table~ and repeat the loop again if there are any more bytes in
the queue.

#+begin_src lua
    if byte == 0x0A then
      table.insert(message_table, byte)
      local message_string = string.char(table.unpack(message_table))
      if not (verify_checksum(message_string)) then
        log_error(ERROR_LIST[2])
        gcs:send_text(0, "ERROR: PTH Data failed checksum")
        message_table = {}
        return update, 100
      end
      if not (parse_data(message_string)) then
        log_error(ERROR_LIST[3])
        gcs:send_text(0, "ERROR: Failed to parse data")
        message_table = {}
        return update, 100
      end
      -- reset for the next message
      message_table = {}
      return update, 100
    end
#+end_src

If we find that the byte we read is in fact the line feed character, we know we
have a full message we can decode.

First we verify that the checksum provided with the message, is correct. This
occurs in the ~verify_checksum()~ function, the specifics of which will be
discussed later in the [[#verifying-checksum]["Verifying Checksum"]] section.

Below is the message format of the PTH sensor. At the end of the message, after
the asterisk, is a two digit hexadecimal number, represented as a string. This
is the checksum of the message.

#+begin_example
$UKPTH,000E,098152.5,Pa,23.17,C,22.90,C,42.21,%,22.45,C*4A<CR><LF>
#+end_example

#+begin_comment
*NOTE*: The end of the message has the standard DOS (Windows) line ending of a
carriage return and a line feed, (shown as <CR> and <LF>). This makes the
message overall 60 characters (bytes), despite there being only 58 visible
characters.
#+end_comment

To calculate the checksum from the message, we take the "main body" of the
message, that is the text inside, but *NOT INCLUDING* the "~$~" and "~*~". The main
body of the message can be seen below.

#+begin_example
UKPTH,000E,098152.5,Pa,23.17,C,22.90,C,42.21,%,22.45,C
#+end_example

Once we have the "main body" of the message, we can now calculate the checksum.
As per the documentation for the sensor:

#+begin_quote
The checksum was calculated as the bit-wise exclusive OR of all 8-bit ASCII
characters between, but not including, ‘$’ and ‘*’ and displayed as a 2-digit
hexadecimal number
#+end_quote

An explanation of the exclusive OR operation (XOR) can be found [[https://en.wikipedia.org/wiki/Exclusive_or][here]].

We take each of the 8-bit ASCII characters in the "main body" of the message
string, and successively XOR each character with the next one.

In the example above, we start out with the ASCII character =U=. We then XOR =U=
with the next character in the string, =K=. After we XOR these two characters
together, we take the result of this operation, and then XOR it with the next
character in the messsage, in this case =P=. We then repeat this process until
we reach the end of the string.

Once we calculate the checksum from the message, we can now verify if the
message is valid. We do this by comparing the value of the checksum we
calculated, to the checksum sent with the message. If the two values do not
match, we know that the data contained within the message, or the checksum bytes
themselves, are corrupted in some manner.

If we find that the checksum is invalid, we report this error to Mission Planner,
call ~log_error()~ to log an error in the BIN file, and clear ~message_table~.

Once the data is verified, we can begin parsing and logging the data. The
specifics will be discussed further in the [[#logging]["Logging"]] and [[#parsing-data]["Parsing Data"]]
sections.

We start by extracting the "main body" of the message into a string. We then
take each section of the message, which is delimited by commas, and place them
into a table.

Once we have a table of all of the sections in the message, we then can then
extract the data sections and place them into their own table.

We then pass this new table of just data values to the ~log_data()~ function,
which logs the data to the BIN file with names for each piece of data, and
their appropriate units.

If the ~log_data()~ function detects that the input table does not meet the
required size of 5 elements, it will return false, and not log the data.  the
~parse_data()~ returns the return value of ~log_data()~ to ~update()~.

When ~parse_data()~ returns false in the above case, or the other cases the
function can detect, ~update()~ reports to Mission Planner that the data
was not successfully, logs an error, and resets the message table.

If both ~verify_checksum()~ and ~parse_data()~ return true, the data that was
read from the serial line was successfully logged. We can now clear the message
table for the next message and continue to reschedule the ~update()~ function to
read the next message.

#+begin_src lua
  return update, 100 -- reschedules the loop every 100ms
#+end_src

Here we schedule the update function to return every 100 milliseconds. We
schedule the loop to run significantly faster that what the Samamet to prevent
cases where we receive more than one message for each run of the ~update()~
function. Receiving more than one message causes us to log the messages that
were recorded around a second apart, but in the log file, show to be around only
three milliseconds apart. To prevent this we simply schedule the loop to run
faster than the sensor sends out its data, and perform some simple checks (that
were discussed earlier) to prevent any false errors from being logged.

** Verifying Checksum

#+caption: Snippet of the ~verify_checksum()~ function, with comments removed.
#+begin_src lua
function verify_checksum(message_string)
  local data_string = message_string:match("%$(.*)%*")

  if data_string == nil then
    return false
  end

  local incoming_checksum = message_string:match("%*([0-9A-F][0-9A-F])")

  if incoming_checksum == nil then
    return false
  end

  incoming_checksum = tonumber(incoming_checksum, 16)

  local checksum = 0x0
  local string_bytes = { data_string:byte(1, #data_string) }
  for i = 1, #string_bytes do
    checksum = (checksum ~ string_bytes[i])
  end

  if checksum ~= incoming_checksum then
    return false
  else
    return true
  end
end
#+end_src

We first take the message string and perform a regular expression (regex or
regexp) match on the string. Here the Lua regex "~%$(.*)%*~" first looks for a
"~$~", once it finds one, it then matches any characters after the "~$~" up
until it finds a "~*~". This extracts the main body of the message, which
contains the data that we need to process for logging. An example of a full
message can be seen below.

#+begin_example
$UKPTH,000E,098152.5,Pa,23.17,C,22.90,C,42.21,%,22.45,C*4A<CR><LF>
#+end_example

Before we continue, we check if the regex failed, if it has, it will have
returned a value of ~nil~. We check for this, and if this is true, we return
false for the caller to handle.

We then perform another regex on the message string again to extract the
checksum. The regex "~%*([0-9A-F][0-9A-F])~" first finds a "~*~". After it finds
one, it then matches exactly two characters. Since we are matching for a
hexadecimal number, the regex will only accept characters in hexadecimal
numbers. This includes all digits between zero and nine, and all capital version
of letters between and including A-F.

Once we have extracted the checksum, we verify that the regex was successful by
making sure the resulting string is not ~nil~. If it is ~nil~, we return false
for the caller to handle.

If we successfully extraced the checksum value, we then need to convert it to an
integer since we cannot compare the string directly with the checksum value we
will calculate later. To do this we call the ~tonumber()~ function. We pass in
the string we want convert to a number, and the base of the number we are
passing in. In this case with a hexadecimal number, we specify =16=.

Now that we have extracted the main message body and the incoming checksum, we
can now calculate the checksum ourselves and verify it is correct.

We start by creating the ~checksum~ variable to hold our calculated checksum and
set it to zero. We do this so we can perform the first XOR with the first
character in the string without causing any issues.

We then need to convert the ~data_string~ variable into an array of bytes. We
need to do this for two reasons. One, we need to be able to iterate over the
string easily, and two, Lua does not support doing bitwise operations, (such as
XOR) on strings or characters directly.

#+begin_src lua
local string_bytes = { data_string:byte(1, #data_string) }
#+end_src

The above code snippet first takes the first character in the string, and
returns its ASCII value. We place this expression inside of a set of curly
braces to take all of the ASCII values of the characters in the string and place
them in a table.

Once we have done that we can finally calculate the checksum. As mentioned
before.  We calculate the checksum by simply XORing each character with the
result of the previous XOR operation.

Once we have calculated the checksum, we compare it with the incoming checksum.
If the two are not the same, we return false, meaning that the data has been
corrupted at some point during the transmission. If the two values are the same,
we return true, as the data has not been effected and we can continue processing
the data.

For information on Lua's regular expressions, you can view these pages:
- [[https://www.lua.org/pil/20.1.html][Pattern-Matching Functions]]
- [[https://riptutorial.com/lua/example/20315/lua-pattern-matching][Lua pattern matching]]

For making patterns and regular expressions in Lua, you can use these web tools:
- [[https://gitspartv.github.io/lua-patterns/][Lua Patterns Viewer]]
- [[https://montymahato.github.io/lua-pattern-tester/][Lua Pattern Tester]]

** Parsing Data

#+caption: Snippet of the ~parse_data()~ function
#+begin_src lua
function parse_data(message_string)
  local data_string = message_string:match("%$(.*)%*")

  if data_string == nil then
    return false
  end

  local data_table = {}

  for str in string.gmatch(data_string, "([^" ..",".. "]+)") do
    table.insert(data_table, str)
  end

  if #data_table ~= 12 then
    return false
  end

  local measurements_table={}
  for i=3,12,2 do
    table.insert(measurements_table, data_table[i])
  end

  -- report data to Mission Planner, not necessary all the time
  -- (OMMITED HERE FOR BREVITY)

  return log_data(measurements_table)

end
#+end_src

We first take the message string and perform a regular expression (regex or
regexp) match on the string. Here the Lua regex "~%$(.*)%*~" first looks for a
"~$~", once it finds one, it then matches any characters after the "~$~" up
until it finds a "~*~". This extracts the main body of the message, which
contains the data that we need to process for logging. An example of a full
message can be seen below.

#+begin_example
$UKPTH,000E,098152.5,Pa,23.17,C,22.90,C,42.21,%,22.45,C*4A<CR><LF>
#+end_example

Before we continue, we check if the regex failed, if it has, it will have
returned a value of ~nil~. We check for this, and if this is true, we return
false for the caller to handle.

After we match the main body of the message, we can start preparing to extract
the date from it. First we initialize the ~data_table~ table, which is where
we will store each of the messages sections for processing.

Next we perform another regex on the message body. Here the regex
"~([^" ..",".. "]+)~", or more simply written as "~([^,]+)~" takes the string,
and matches every character up until it finds a '=,='. It does this for all
of the segments in the string. We then use the for loop to iterate over all of
these segments and place them into are previously defined ~data_table~.

We then check the size of ~data_table~ to ensure it got all twelve segments we
are expecting, if not, we return false for the caller to handle.

We then take the measurement values from ~data_table~ and place them into a
new table called ~measurements_table~.

After we have extracted the measurement values, we can optionally send the
values to the Mission Planner output, but is not required for the script to
function.

Finally we call ~log_data~ and pass in the ~measurements_table~ as an argument.
~log_data()~ returns true or false depending on whether the table is the correct
size. We then return this boolean value to the caller for them to handle.

For information on Lua's regular expressions, you can view these pages:
- [[https://www.lua.org/pil/20.1.html][Pattern-Matching Functions]]
- [[https://riptutorial.com/lua/example/20315/lua-pattern-matching][Lua pattern matching]]

For making patterns and regular expressions in Lua, you can use these web tools:
- [[https://gitspartv.github.io/lua-patterns/][Lua Patterns Viewer]]
- [[https://montymahato.github.io/lua-pattern-tester/][Lua Pattern Tester]]

** Logging
*** Logging Data

#+caption: Snippet of the ~log_data()~ function, with comments removed.
#+begin_src lua
function log_data(measurements_table)
  if #measurements_table ~= 5 then
    return false
  end
  logger:write('SAMA', 'pres,temp1,temp2,hum,temp3,error',
               'NNNNNN',
               'POO%O-',
               '------',
               measurements_table[1],
               measurements_table[2],
               measurements_table[3],
               measurements_table[4],
               measurements_table[5],
               "Normal")
  return true
end
#+end_src

Above is the ~log_data()~ function. This function takes in a table as an
argument.

The function first checks if the table that is passed to it is the correct size,
in this case 5, as that is the number of sensors on the PTH. If it does not pass
this check, ~log_data()~ returns a =false= value, which is processed by the
caller.

If the table passes this check, we then write the data to the BIN file.

The ~logger:write~ method take several arguments to define the various
parameters that go into the log file.

The first argument, '=SAMA=', is the section name for the data we are going to
log in the file. This name has to be at most 4 characters, and cannot be the
same as any other section name that ArduPilot logs. The second argument,
'=pres,temp1,temp2,hum,temp3,error=', specifies the name of each piece of data
logged.  These labels are stored under the section name in the log file, in
total these names cannot exceed 64 characters.

The third argument, '=NNNNNN=', specifies the type of each label. In this case
'=N=', specifies a =char[16]=, which is a string of a maximum of 16 characters.
The fourth and fifth arguments specify the units and the multiplier of each of
the units respectively. In the fourth argument '=P=' represents Pascals, for the
pressure measurement, '=O=' represents degrees Celsius, for the temperature
measurements, and '=%=' for percentage, for the humidity measurements, and '=-='
for no units/string for the error column. For the fifth argument, the '=-='
specifies that we want no multiplier applies to our data.

Further explanations on the format, unit, and multiplier types can be
found [[https://github.com/ArduPilot/ardupilot/blob/master/libraries/AP_Logger/README.md][here]].

Once we specify the parameters for the data that is going to be logged, we then
pass in the data we would like to log in the file. In this case, we use the 5
elements in the ~measurements_table~ table, and the string "=Normal=" for the
error column. These are in the same order as the labels we specified in the
second argument.

Further explanation on the arguments of the ~logger:write()~ method can be found
[[https://ardupilot.org/dev/docs/code-overview-adding-a-new-log-message.html][here]].

Once we log the data we simply return true to the caller for them to handle.
~logger:write()~ unfortunately does not return a value to tell us whether it was
successful so we can only assume that it wrote to the BIN file correctly.

*** Logging Errors

#+caption: The ~log_error()~ function, with comments removed.
#+begin_src lua
function log_error(error_type)
  logger:write('SAMA', 'pres,temp1,temp2,hum,temp3,error',
               'NNNNNN',
               'POO%O-',
               '------',
               '0', '0', '0', '0', '0', error_type)
end
#+end_src

The ~log_errors()~ is very similar to the ~log_data()~ function, the only
difference is that instead of writing any specific data, we simply write zeros
to the log file, and log the type of error as a string (which will originate
from the ~ERROR_LIST~ table). We do this as it is very obvious in the log file
when there is an error, and we deal with it easily during post processing.

For an explanation of the arguments, in ~logger:write()~, you can look in the
[[#logging-data]["Logging Data"]] section

** Important Notes
If a Lua script has an error that the Lua interpreter detects, the script it
generally not able to be restarted until the autopilot is manually restarted or
a restart script command is sent. This is why there are several checks to ensure
that the data parsing operations work as expected.

Doing this, and letting the script still run after an error is detected is
important, as it prevent the script from crashing from a minor issue that fixes
itself immediately, such as minor data corruption, or a short in a sensor
connection, that causes a temporary disconnection. After the issue resolves
itself, assuming the script can handle the error, the script can continue
logging without having to land a drone and restart the script, which is vital
for long and important flights.


#+latex: \newpage
* Important Links
Below is a list of the URLs linked to in the document in case that the
hyperlinks are not usable or reachable, such as if the document is printed on
paper.

1. ArduPilot Serial Dump Example
   + https://github.com/ArduPilot/ardupilot/blob/master/libraries/AP_Scripting/examples/Serial_Dump.lua
2. Exclusive OR Wikipedia Article
   + https://en.wikipedia.org/wiki/Exclusive_or
3. Formatting, Units, and Multipliers in ArduPilots Logging System
   + https://github.com/ArduPilot/ardupilot/blob/master/libraries/AP_Logger/README.md
4. ArduPilot adding a new log message
   + https://ardupilot.org/dev/docs/code-overview-adding-a-new-log-message.html
5. Lua Pattern-Matching Functions
   + https://www.lua.org/pil/20.1.html
6. Lua Pattern Matching
   + https://riptutorial.com/lua/example/20315/lua-pattern-matching
7. Lua Patterns Viewer
   + https://gitspartv.github.io/lua-patterns/
8. Lua Pattern Tester
   + https://montymahato.github.io/lua-pattern-tester/

#  LocalWords:  ArduPilot Lua regexes Samamet
